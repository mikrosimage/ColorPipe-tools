""" LUT preset
    A preset is a dict containing LUT parameters.
    The dict must have these attributes:
    {
    'type': <'default' or '1D' or '2D' or '3D'>,
    'extension': <str value>,
    'input_range': <[int/float, int/float]>,
    'output_range': <[int/float, int/float]>,
    'output_bitdepth': <int value>,
    'cube_size': <int value>,
    'title': <str value>,
    'comment': <str value>,
    'version': <str value>
    }
    See attribute constant below.

    When 1D or 2D type is chosen, preset must define output_bitdepth but
    shouldn't define cube_size.

    When 3D is chosen, preset must define cube_size but shouldn't define
    output_bitdepth.

    'default' is used to declare default sets, it must define both
    output_bitdepth and cube_size

.. moduleauthor:: `Marie FETIVEAU <github.com/mfe>`_

"""
__version__ = "0.2"
import collections
from utils.color_log_helper import print_warning_message


class PresetException(Exception):
    """Module custom exception

    """
    pass

# Attributes
TYPE = 'type'
TYPE_CHOICE = ['default', '1D', '2D', '3D']
EXPORT_CHOICE = ['1D', '2D', '3D']
EXT = 'extension'
VERSION = 'version'
TITLE = 'title'
COMMENT = 'comment'
IN_RANGE = 'input_range'
OUT_RANGE = 'output_range'

# 1D / 2D specific attribute
OUT_BITDEPTH = 'output_bitdepth'

# Smooth Specify how many points are computed.
# A first subsampled curve is first processed and then resample with
# a smooth to fit input lutsize.
# So the smaller this value is, the smoother the curve will be.
# 1D / 2D only
# Ex: 10, 20,...
SMOOTH = 'smooth'

# 3D specific attribute
CUBE_SIZE = 'cube_size'

BASIC_ATTRS = [TYPE, EXT, VERSION, TITLE, COMMENT, IN_RANGE, OUT_RANGE]

BITDEPTH_MAX_VALUE = 128
BITDEPTH_MIN_VALUE = 8
CUBE_SIZE_MAX_VALUE = 128
CUBE_SIZE_MIN_VALUE = 3

FLOAT_BOUNDARY = 100.0

RAISE_MODE = 'raise'
FILL_MODE = 'fill'

MISSING_ATTR_MESSAGE = "Preset must have '{0}' attribute"


def get_default_preset():
    """ Get a general default preset.
        Values were chosen considering common LUT use cases.

    """
    return {
                TYPE: "default",
                EXT: ".lut",
                IN_RANGE: [0.0, 1.0],
                OUT_RANGE: [0.0, 1.0],
                OUT_BITDEPTH: 12,
                CUBE_SIZE: 17,
                TITLE: "LUT",
                COMMENT: ("Generated by ColorPipe-tools"
                            ).format(__version__),
                VERSION: "1"
           }


def is_range(arange):
    """ Return True if range is a collection composed of 2 int or float

    """
    if not isinstance(arange, collections.Iterable):
        return False
    if len(arange) != 2:
        return False
    for value in arange:
        if not isinstance(value, (int, float)):
            return False
    return True


def is_3d_preset(preset):
    """ Check if preset is valid for 3D LUTs
        Should be used after a check or complete

    """
    if preset[TYPE] == 'default' or preset[TYPE] == '3D':
        return True
    return False


def is_1d_or_2d_preset(preset):
    """ Check if preset is valid for 1D / 2D LUTs
        Should be used after a check or complete

    """
    if (preset[TYPE] == 'default'
        or preset[TYPE] == '1D'
        or preset[TYPE] == '2D'):
        return True
    return False


def is_int(arange):
    """ Check if a range is int

    Args:
        test_range ([int/float, int/float]): range to test

    Returns:
        .boolean

    """
    if (isinstance(arange[0], int)
        and isinstance(arange[1], int)):
        return True
    return False


def _get_range_float_message(arange):
    """ Get range warning/error message

    Returns:
        .str

    """
    return ("Range is expected to be float."
            " Ex: [0.0, 1.0] or [-0.25, 2.0].\nYour range {0}"
            ).format(arange)


def _get_range_int_message(arange):
    """ Get range warning/error message

    Returns:
        .str

    """
    return ("Range is expected to be int."
            " Ex: [0, 1023] or [0, 65535].\nYour range {1}"
            ).format(arange)


def check_range_is_float(arange, message=None):
    """ Check output range. Some LUT are float.
        Print a warning or raise an error

    """
    if message is None:
        message = _get_range_float_message(arange)
    if is_int(arange):
        raise PresetException(message)
    elif arange[1] > FLOAT_BOUNDARY:
        message = ("{0} seems too big !\n"
                   "Please check this, if the LUT isn't what you expected"
                   ).format(message)
        print_warning_message(message)


def check_range_is_int(arange, message=None):
    """ Check input / output range. Some LUT are int.
        Print a warning or raise an error

    """
    if message is None:
        message = _get_range_int_message(arange)
    if not is_int(arange):
        raise PresetException(message)
    elif arange[1] < BITDEPTH_MAX_VALUE:
        message = ("{0} seems too low !\n"
               "Please check this, if the LUT isn't what you expected"
               ).format(message)
        print_warning_message(message)


def convert_string_to_number(string):
    """ Convert a string number into a float or an int

    """
    try:
        return int(string)
    except ValueError:
        return float(string)


def convert_string_range(arange):
    """ Convert a string number range into a float or an int

    """
    return [convert_string_to_number(value) for value in arange]


def string_preset(preset):
    """ Print preset

    """
    string = '{\n'
    for attr in preset.keys():
        string = "{0}  {1}: {2},\n".format(string, attr, preset[attr])
    string += '}\n'
    return string
